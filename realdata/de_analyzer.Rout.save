
R version 3.2.2 (2015-08-14) -- "Fire Safety"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #suppressPackageStartupMessages(require(simpaler))
> #suppressPackageStartupMessages(require(TxDb.Mmusculus.UCSC.mm10.ensGene))
> suppressPackageStartupMessages(require(edgeR))
> suppressPackageStartupMessages(require(DESeq2))
> 
> for (data in c("ola", "scialdone")) {
+     if (data=="ola") {
+         host.dir <- "."
+         all.counts <- read.table("ESpresso/counttable_es.csv", header=TRUE, row.names=1, colClasses=c("character", rep("integer", 704)))
+         serum <- sub("ola_mES_([^_]+)_.*", "\\1", colnames(all.counts))
+         batch <- sub("ola_mES_[^_]+_([^_]+)_.*", "\\1", colnames(all.counts))
+         targets <- data.frame(Serum=serum, Batch=batch)
+ 
+         # Only using data from two batches.
+         keep <- targets$Batch %in% c("2", "3")
+         all.counts <- all.counts[,keep]
+         targets <- targets[keep,]
+         targets$Plate <- as.integer(factor(paste0(targets$Serum, targets$Batch)))
+         targets[] <- lapply(targets, factor)
+         targets$Serum <- factor(targets$Serum, c("lif", "2i", "a2i"))
+     } else {
+         whee <- new.env()
+         load("Scialdone_Gastrulation/aaron_data_gastrulation.RData", env=whee)
+         all.counts <- whee$data 
+         targets <- data.frame(whee$labels)
+         targets[] <- lapply(targets, factor)
+     }
+ 
+     # Quality control on genes (QC on cells already done).
+     is.mouse <- grepl("^ENSMUSG", rownames(all.counts))
+ 
+ #    chr.loc <- findChr(rownames(all.counts[is.mouse,]), TxDb.Mmusculus.UCSC.mm10.ensGene)
+ #    lib.sizes <- colSums(all.counts[is.mouse,])
+ #    okay.libs <- lib.sizes > 1e5 & colSums(all.counts[is.mouse,][!is.na(chr.loc) & chr.loc=="chrM",])/lib.sizes < 0.1
+ 
+ #    all.counts <- all.counts[,okay.libs]
+ #    targets <- targets[okay.libs,]
+ 
+     of.interest <- is.mouse & rowMeans(all.counts) >= 1
+     all.counts <- all.counts[of.interest,]
+ 
+     # Formulating the design matrix.
+     if (data=="ola") {
+         model.formula <- ~Batch + Serum
+         comparisons <- list(c("Serum", "2i", "lif"), c("Serum", "a2i", "lif"))
+         coefs <- c(3, 4)
+     } else {
+         model.formula <- ~Stage
+         comparisons <- list(c("Stage", "NP", "PS"))
+         coefs <- 2
+     }
+     refdesign <- model.matrix(model.formula, data=targets)
+    
+     for (type in c("raw", "sum")) { 
+         if (type=="raw") { 
+             counts <- all.counts
+             design <- refdesign
+             deseq.target <- targets
+         } else {
+             counts <- sumTechReps(all.counts, targets$Plate)
+             first.in.each <- !duplicated(targets$Plate)
+             design <- refdesign[first.in.each,]
+             deseq.target <- targets[first.in.each,]
+         }
+ 
+         # Analyzing with edgeR. 
+         y <- DGEList(counts)
+         y <- calcNormFactors(y)
+         y <- estimateDisp(y, design, prior.df=0)
+         fit <- glmQLFit(y, design, robust=TRUE)
+ 
+         for (i in seq_along(coefs)) { 
+             res <- glmQLFTest(fit, coef=coefs[i]) 
+             fhandle <- gzfile(paste0("results/edgeR_", data, i, "_", type, ".tsv.gz"), open="wb")
+             write.table(topTags(res, n=Inf, sort.by="none")$table, file=fhandle,
+                         col.names=NA, sep="\t", quote=FALSE)
+             close(fhandle)
+ 
+         }
+         save(y, design, file=paste0("results/objects_", data, "_", type, ".Rda")) # The DGEGLM objects are huge, so we'll go without.     
+ 
+         # Analyzing with voom.
+         v.all <- voom(y, design)
+         fit <- lmFit(v.all, design)
+         fit <- eBayes(fit, robust=TRUE)
+ 
+         for (i in seq_along(coefs)) { 
+             res <- topTable(fit, n=Inf, sort.by="none", coef=coefs[i])
+             fhandle <- gzfile(paste0("results/voom_", data, i, "_", type, ".tsv.gz"), open="wb")
+             write.table(res, file=fhandle, col.names=NA, sep="\t", quote=FALSE)
+             close(fhandle)
+         }
+ 
+         # Analyzing with DESeq2.
+         suppressMessages(dds <- DESeqDataSetFromMatrix(counts, colData=deseq.target, design=model.formula))
+         suppressMessages(dds <- DESeq(dds))
+         for (i in seq_along(comparisons)) {
+             res <- results(dds, comparisons[[i]])
+             fhandle <- gzfile(paste0("results/DESeq2_", data, i, "_", type, ".tsv.gz"), open="wb")
+             write.table(res, file=fhandle, col.names=NA, sep="\t", quote=FALSE)
+             close(fhandle)
+         }
+     }
+ }
> 
> #######################################################
> # Comparing the various types of analyses.
> 
> compare.all <- function(qval1, qval2, threshold=0.05) {
+     sig1 <- qval1 <= threshold & !is.na(qval1)
+     sig2 <- qval2 <= threshold & !is.na(qval2)
+     return(list(total1=sum(sig1), total2=sum(sig2), shared=sum(sig1 & sig2)))
+ }
> 
> compare.top <- function(pval1, pval2, top=c(20, 200, 2000)) {
+     output <- list()
+     o1 <- rank(pval1, ties.method="first")
+     o2 <- rank(pval2, ties.method="first") 
+     for (x in top) {
+         output[[as.character(x)]] <- sum(o1 <= x & o2 <= x)/x
+     }
+     return(output)
+ }
> 
> log.all <- "results_all.txt"
> log.top <- "results_top.txt"
> if (file.exists(log.all)) { unlink(log.all) }
> if (file.exists(log.top)) { unlink(log.top) }
> 
> for (con in c("ola1", "ola2", "scialdone1")) {
+     v.sum  <- read.table(paste0("results/voom_", con, "_sum.tsv.gz"), header=TRUE, row.names=1)
+     v.cell <- read.table(paste0("results/voom_", con, "_raw.tsv.gz"), header=TRUE, row.names=1)
+     all.v <- compare.all(v.cell$adj.P.Val, v.sum$adj.P.Val)
+     top.v <- compare.top(v.cell$P.Value, v.sum$P.Value)
+ 
+     d.sum  <- read.table(paste0("results/DESeq2_", con, "_sum.tsv.gz"), header=TRUE, row.names=1)
+     d.cell <- read.table(paste0("results/DESeq2_", con, "_raw.tsv.gz"), header=TRUE, row.names=1)
+     all.d <- compare.all(d.cell$padj, d.sum$padj)
+     top.d <- compare.top(d.cell$pvalue, d.sum$pvalue)
+ 
+     e.sum  <- read.table(paste0("results/edgeR_", con, "_sum.tsv.gz"), header=TRUE, row.names=1)
+     e.cell <- read.table(paste0("results/edgeR_", con, "_raw.tsv.gz"), header=TRUE, row.names=1)
+     all.e <- compare.all(e.cell$FDR, e.sum$FDR)
+     top.e <- compare.top(e.cell$PValue, e.sum$PValue)
+     
+     # Easier to put the separators in, as we need "&" at the front and "\\" at the end.
+     write(sprintf("& %s & %i & %i & %i \\\\", c("Cell", "Sum", "Shared"), unlist(all.d), unlist(all.v), unlist(all.e)), file=log.all, append=TRUE)
+     write(file=log.all, "\\hline", append=TRUE)
+     write(sprintf("& %s & %.2f & %.2f & %.2f \\\\", names(top.v), unlist(top.d), unlist(top.v), unlist(top.e)), file=log.top, append=TRUE) 
+     write(file=log.top, "\\hline", append=TRUE)
+ }
> 
> #######################################################
> 
> sessionInfo()
R version 3.2.2 (2015-08-14)
Platform: x86_64-pc-linux-gnu (64-bit)

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] DESeq2_1.10.0              RcppArmadillo_0.6.300.2.0 
 [3] Rcpp_0.12.2                SummarizedExperiment_1.0.1
 [5] Biobase_2.30.0             GenomicRanges_1.22.1      
 [7] GenomeInfoDb_1.6.1         IRanges_2.4.5             
 [9] S4Vectors_0.8.5            BiocGenerics_0.16.1       
[11] edgeR_3.12.0               limma_3.26.3              

loaded via a namespace (and not attached):
 [1] RColorBrewer_1.1-2   futile.logger_1.4.1  plyr_1.8.3          
 [4] XVector_0.10.0       futile.options_1.0.0 tools_3.2.2         
 [7] zlibbioc_1.16.0      statmod_1.4.22       rpart_4.1-10        
[10] digest_0.6.8         RSQLite_1.0.0        annotate_1.48.0     
[13] gtable_0.1.2         lattice_0.20-33      DBI_0.3.1           
[16] proto_0.3-10         gridExtra_2.0.0      genefilter_1.52.0   
[19] cluster_2.0.3        stringr_1.0.0        locfit_1.5-9.1      
[22] nnet_7.3-11          grid_3.2.2           AnnotationDbi_1.32.2
[25] XML_3.98-1.3         survival_2.38-3      BiocParallel_1.4.0  
[28] foreign_0.8-66       latticeExtra_0.6-26  Formula_1.2-1       
[31] geneplotter_1.48.0   ggplot2_1.0.1        reshape2_1.4.1      
[34] lambda.r_1.1.7       magrittr_1.5         scales_0.3.0        
[37] Hmisc_3.17-0         MASS_7.3-45          splines_3.2.2       
[40] xtable_1.8-0         colorspace_1.2-6     stringi_1.0-1       
[43] acepack_1.3-3.3      munsell_0.4.2       
> 
> #######################################################
> # End.
> 
> proc.time()
     user    system   elapsed 
28490.254   484.909 29183.969 
